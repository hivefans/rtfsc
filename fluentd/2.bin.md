# intro

项目地址：[fluentd](https://github.com/fluent/fluentd?source=c)

项目官网：[http://fluentd.org/](http://fluentd.org/)

项目描述：一个ruby编写的日志搜集系统。Log Everything in JSON

fluentd是最近在使用的一个日志收集系统，它可以很方便的为其编写不同的输入输出插件，并且已经有了很多支持：[plugin](http://fluentd.org/plugin/)。因为工作中经常使用ruby，所以便对其源码产生了兴趣，我将对其进行一步步细致的分析学习，以加深对ruby的理解和更好的使用它。

READ THE * SOURCE CODE.

整个项目路径如下：

```
AUTHORS         Gemfile         bin             fluentd.gemspec
COPYING         README.rdoc     conf            lib
ChangeLog       Rakefile        fluent.conf     test
```

下一节：[bin分析](https://github.com/zhuoyikang/rtfsc/blob/master/fluentd/2.bin.md)

# 2. 可执行文件(bin)

[bin](https://github.com/fluent/fluentd/tree/master/bin) 路径下存放了fluentd的可执行文件脚本：

## 2.1 fluent-cat

fluent-cat是fluentd的一个客户端，它通过标准输入给fluentd发送消息，github上的readme已经演示过了。

```
#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
require 'rubygems' unless defined?(gem)
here = File.dirname(__FILE__)
$LOAD_PATH << File.expand_path(File.join(here, '..', 'lib'))
require 'fluent/command/cat'
```

`$LOAD_PATH`指的是Ruby读取外部文件的一个环境变量，其实和windows的环境变量是一个概念。Ruby会在这个环境变量的路径中读取需要require的文件，如果在环境变量中找不到自己想要的文件，就会报LoadError错误。`$LOAD_PATH`也可写作`$:`。

`__FILE__` 指的是当前rb文件所在目录的相对位置。

File.join是把自己的参数组成一个目录形式的方法

所以上面的代码假定了你会在fluentd路径下执行，并且将lib文件夹增加到环境变量以便于require里面的fluent代码。

于是找到lib/fluntd/command/cat文件.

## 2.2 fluent/command/cat

[代码链接](https://github.com/fluent/fluentd/blob/master/lib/fluent/command/cat.rb)
[OptionParser.html](http://ruby-doc.org/stdlib-2.0/libdoc/optparse/rdoc/OptionParser.html)

```
require 'optparse'
require 'fluent/env'

op = OptionParser.new
```
optparse是解析ruby命令行代码的库，当然还有其他库，不过没有optparse做的好:

使用以下代码添加不同的参数解析:

```
op.on('-p', '--port PORT', "test tcp port (default #{port})", Integer) { |i|
  port = i
}
```

使用`op.to_s`产生 usage 字符串，下面的代码在当前作用于产生了一个usage函数:

```
(class<<self;self;end).module_eval do
  define_method(:usage) do |msg|
    puts op.to_s
    puts "error: #{msg}" if msg
    exit 1
  end
end
```
直接定义一个`def usage`函数不能够使用到外部的`op`变量，而这种动态编程方法可以，称为作用域扁平化，这样可以避免把op定义为全局变量，是ruby中很常见的编程trick。

```
begin
  op.parse!(ARGV)

  if ARGV.length != 1
    usage nil
  end

  tag = ARGV.shift

rescue
  usage $!.to_s
end
```

`ARGV` 是ruby程序使用的参数的常量数组。而`$!`是一个ruby默认的全局变量：

* $! 最近一次的错误信息
* $@ 错误产生的位置
* $_ gets最近读的字符串
* $. 解释器最近读的行数(line number)
* $& 最近一次与正则表达式匹配的字符串
* $~ 作为子表达式组的最近一次匹配
* $n 最近匹配的第n个子表达式(和$~[n]一样)
* $= 是否区别大小写的标志
* $/ 输入记录分隔符
* $\ 输出记录分隔符
* $0 Ruby脚本的文件名
* $* 命令行参数
* $$ 解释器进程ID
* $? 最近一次执行的子进程退出状态

这里有篇 [demo](http://www.cnblogs.com/lwm-1988/archive/2012/04/19/2456932.html)。

下面require了若干个库:

```
require 'thread'
require 'monitor'
require 'socket'
require 'yajl'
require 'msgpack'
```

### 2.2.1 thread

Ruby的多线程编程库，先学习一下其基本用法：

[thread](https://github.com/zhuoyikang/rtfsc/blob/master/fluentd/thread_tr.rb)

```
require 'thread'
require 'net/http'
pages = %w(www.iteye.com www.csdn.net www.sina.com.cn www.google.cn)
threads = []

for page in pages
  threads << Thread.new(page) do |url|
    h = Net::HTTP.new(url, 80)
    puts "The URL is #{url} #{h}"
    resp = h.get('/')
    puts "The #{url} response:#{resp.message}"
  end
end

threads.each { |t|t.join  }
```
Ruby中使用的线程是用户级线程，由Ruby解释器进行切换管理。其效率要低于由OS管理线程的效率，且不能使用多个CPU。

[官方文档](http://ruby-doc.org/core-2.0/Thread.html)

### 2.2.2 线程同步

有线程就有线程同步机制：

[*Mutex*](https://github.com/zhuoyikang/rtfsc/blob/master/fluentd/mutex_tr.rb)

Mutex是mutual-exclusion lock（互斥锁）的简称。若对Mutex加锁时发现已经处于锁定状态时，线程会挂起直到解锁为止。

在并行访问中保护共享数据时，可以使用下列代码（m是Mutex的实例）

```
begin
   m.lock
   # 访问受m保护的共享数据
ensure
   m.unlock
end
```

Mutex有个synchronize方法可以简化这一过程。

```
m.synchronize {
   # 访问受m保护的共享数据
}
```

[*Queue*](https://github.com/zhuoyikang/rtfsc/blob/master/fluentd/queue_tr.rb)

Queue就像一条读写数据的管道。提供数据的线程在一边写入数据，而读取数据的线程则在另一边读出数据。若Queue中没有可供读取的数据时，读取数据的线程会挂起等待数据的到来。

```
require 'thread'

q = Queue.new

(1..10).each do
  Thread.new {
    while line = q.pop
      print "#{Thread.current} #{line}"
    end
  }
end

while (u = gets)
  q.push(u)
end
```
当你输入字符串的时候，可以看到每次`Thread.current`都不一样。

[*Monitor*](https://github.com/zhuoyikang/rtfsc/blob/master/fluentd/monitor_tr.rb)

monitor和mutex最大的区别是mutx不可以嵌套，但monitor可以。

```
require 'monitor'

#和mutex一样的用法，但是嵌套没有问题.
lock = Monitor.new
lock.synchronize do
  lock.synchronize do
    puts "nce"
  end
end
```

可以通过继承monitor获取其synchronize方法：

```
class Counter < Mutex
  attr_reader :number
  def initialize
    @number = 0
    super # 初始化父类数据
  end

  def plus
    synchronize do
      @number += 1
    end
  end
end

c = Counter.new
t1 = Thread.new { 10000.times { c.plus } }
t2 = Thread.new { 10000.times { c.plus } }
t1.join
t2.join
puts c.number
```

或者将其mixin:

```
class Counter
    include MonitorMixin
	…
end
```

以上内容基本就是ruby的线程同步机制了，现在看fluentd:

### 2.2.3 writer

Writer mixin Monitor，而TimerThread是一个简单的定时器实现。

```
class Writer
  include MonitorMixin

   class TimerThread
    def initialize(writer)
      @writer = writer
    end

	# 以TimerThread的run方法开始一个线程，而已。
    def start
      @finish = false
      @thread = Thread.new(&method(:run))
    end

    def shutdown
      @finish = true
      @thread.join
    end

    def run
      until @finish
        sleep 1
        @writer.on_timer
      end
    end

end
```
[MessagePack](http://msgpack.org/) 是一种高性能的二进制序列化格式，它可以让你在多种不同的语言之间交换数据，其支持的语言非常多，也非常成熟，是一种跨语言的基于二进制的数据格式。从官方的介绍来看，它能够比google protocol buffers快4倍，比json快10倍多。

```
Ruby Python Perl C/C++ Java Scala PHP
Lua JavaScript Node.js Haskell C#
Objective-C Erlang D OCaml Go LabVIEW Smalltalk

"Fluentd uses MessagePack for all internal data representation. It's crazy fast because of zero-copy optimization of msgpack-ruby. Now MessagePack is an essential component of Fluentd to achieve high performance and flexibility at the same time."

Sadayuki Furuhashi, creator of Fluentd.
```
或许MessagePack也可以用作游戏通信协议，可以再深入评定一下。

与JSON的比较 

1.序列化和反序列化所需要的时间少。通过30000条的记录来测试，msgpack序列化的时间比使用jason来序列化JSON的时间要少三分之一；而反序列化的时间则要少一半。
 
2.生成的文件体积小。同样也是基于30000条记录来测试，msgpack序列化后生成的二进制文件比用jason序列化出来的时间要少一半。 

[Yajl](https://github.com/brianmario/yajl-ruby) :A streaming JSON parsing and encoding library for Ruby (C bindings to yajl)

[yajl-ruby doc](http://rdoc.info/github/brianmario/yajl-ruby)

```
JSON parsing and encoding directly to and from an IO stream (file, socket, etc) or String. Compressed stream parsing and encoding supported for Bzip2, Gzip and Deflate.
Parse and encode multiple JSON objects to and from streams or strings continuously.
JSON gem compatibility API - allows yajl-ruby to be used as a drop-in replacement for the JSON gem
Basic HTTP client (only GET requests supported for now) which parses JSON directly off the response body *as it's being received*
~3.5x faster than JSON.generate
~1.9x faster than JSON.parse
~4.5x faster than YAML.load
~377.5x faster than YAML.dump
~1.5x faster than Marshal.load
~2x faster than Marshal.dump
```

这个只是为了展示内容用的，序列化格式还是msgpack。

```
def get_socket
    unless @socket
      unless try_connect
        return nil
      end
    end

    @socket_time = Time.now.to_i
    return @socket
  end
```

整个cat命令是通过socket和fluentd进程通信，也就是它是一个fluentd的客户端，所以有一堆处理连接的代码，包括try_connect函数。

真正的将数据写入连接是在函数:

```
def write_impl(array)
    socket = get_socket
    unless socket
      return false
    end

    begin
      socket.write [@tag, array].to_msgpack
      socket.flush
    rescue
      $stderr.puts "write failed: #{$!}"
      close
      return false
    end

    return true
  end
```
接下来的代码将获取标准输入，将其发送到fluentd了：

```
case format
when 'json'
  begin
    while line = $stdin.gets
      record = Yajl.load(line)
      w.write(record)
    end
  rescue
    $stderr.puts $!
    exit 1
  end
```

默认的fluentd的配置在env中获得`require 'fluent /env'`。

由于ThreadTimer，Writer对象的on_timer方法会被1s间隔的调用，每次调用会将@pending数组的数据尝试写到服务器。

以上内容就是cat命令。


## 2.3 bin/*

bin路径下还有其他几个命令, fluent-cat fluent-debug fluent-gem fluentd，他们的代码都和fluent-cat差不多，主要的逻辑功能还是在lib/fluent/command中实现。
